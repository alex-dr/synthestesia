/**
  * This sketch demonstrates how to use an FFT to analyze
  * the audio being generated by an AudioPlayer.
  * <p>
  * FFT stands for Fast Fourier Transform, which is a
  * method of analyzing audio that allows you to visualize
  * the frequency content of a signal. You've seen
  * visualizations like this before in music players
  * and car stereos.
  * <p>
  * For more information about Minim and additional features,
  * visit http://code.compartmental.net/minim/
  */

import ddf.minim.analysis.*;
import ddf.minim.*;

Minim       minim;
Song song;
String windowName;

/**
 * HARDCODES
 */
// filename of song, relative to project
// String SONG_NAME = "example-music/bensound-cute.mp3";
//  String SONG_NAME = "example-music/bensound-buddy.mp3";
// String SONG_NAME = "example-music/bensound-happyrock.mp3";
// String SONG_NAME = "example-music/bensound-acousticbreeze.mp3";
String SONG_NAME = "example-music/bensound-summer.mp3";
// String SONG_NAME = "my-music/bach-ave-maria.mp3";
// String SONG_NAME = "my-music/clair-de-lune.mp3";
// String SONG_NAME = "my-music/gjeilo-ubi-caritas.mp3";
// String SONG_NAME = "my-music/bach-dazu-ist.mp3";
// String SONG_NAME = "my-music/frequency-decree-kawaii.mp3";
// String SONG_NAME = "my-music/blue-wave-theory-living-nightmare.mp3";
// String SONG_NAME = "my-music/that-crooner-from-nowhere-fun-fat-fun.mp3";
// String SONG_NAME = "my-music/kimiko-ishizaka-variatio-5a1-ovvero-2-clav.mp3";
// String SONG_NAME = "my-music/james-kibbie-bwv-549-prelude-and-fugue-in-c-minor-2-fuga.mp3";
// String SONG_NAME = "my-music/bach-cello-suite-5-1-prelude.mp3";
// String SONG_NAME = "my-music/bach-cello-suite-2-1-prelude.mp3";
// sample rate of the FFT
int FFT_SAMPLES = 1024 * 2;
// Vertical scaling factor, controlled with -/= keys
int GAIN = 2;
// Number of subdivisions in the color map
int NUM_COLORS = 256;
// First index of the spectrum to use
int MIN_INDEX = 8;
// display extra debug info
boolean DEBUG = true;

// which spectrum mapping to use for pitch -> color
public enum SpecType {
    // ROY G BIV is my man
    RAINBOW,
    // Circle of Fifths Coloring
    COF
}

SpecType SPECTYPE = SpecType.RAINBOW;

public enum Mode {
    LINEIN,
    MUSIC
}

Mode PLAY_MODE = Mode.MUSIC;

/**
 * DISCOVERED CONSTANTS
 */
// Elements in the spectrum
int SPECTRUM_SIZE;
// Size of each frequency band in the spectrum
float BANDWIDTH;
// map integer frequencies to hues
int[] HUE_MAP;
// Min/max possible frequency in the spectrum
int MIN_FREQ;
int MAX_FREQ;

/**
 * Processing Framework functions
 */
void setup()
{
    size(2048, 800, P3D);
    colorMode(HSB, NUM_COLORS);

    minim = new Minim(this);
    song = new Song(minim, SONG_NAME, FFT_SAMPLES);
    Thread songthread = new Thread(song);

    SPECTRUM_SIZE = song.fft_l.specSize() - MIN_INDEX;
    BANDWIDTH = song.fft_l.getBandWidth();

    System.out.println("Loaded song name: " + SONG_NAME);
    System.out.println("Song samples: " + FFT_SAMPLES);
    System.out.println("Song specsize: " + SPECTRUM_SIZE);
    System.out.println("Bandwidth: " + song.fft_l.getBandWidth());

    MIN_FREQ = (int) song.fft_l.indexToFreq(MIN_INDEX);
    MAX_FREQ = (int) song.fft_l.indexToFreq(SPECTRUM_SIZE);
    System.out.println("Min frequency: " + MIN_FREQ);
    System.out.println("Max frequency: " + MAX_FREQ);
    System.out.println("2nd Frequency: " + song.fft_l.indexToFreq(MIN_INDEX+1));

    fillColorMap(song);
    songthread.start();

    textFont(createFont("Arial", 16));

    windowName = "Rectangular Window";
}

void draw()
{
    background(0);
    stroke(255);
    fill(255);

    drawBars();
    drawWaveform();
    drawDebug();
}

void keyReleased() {
    WindowFunction newWindow = FFT.NONE;
    
    switch (key) {
        case '1': newWindow = FFT.BARTLETT; break;
        case '2': newWindow = FFT.BARTLETTHANN; break;
        case '3': newWindow = FFT.BLACKMAN; break;
        case '4': newWindow = FFT.COSINE; break;
        case '5': newWindow = FFT.GAUSS; break;
        case '6': newWindow = FFT.HAMMING; break;
        case '7': newWindow = FFT.HANN; break;
        case '8': newWindow = FFT.LANCZOS; break;
        case '9': newWindow = FFT.TRIANGULAR; break;
        case '=': GAIN += 1; break;
        case '-': GAIN -= 1; break;
    }

    song.fft_l.window(newWindow);
    song.fft_r.window(newWindow);
    windowName = newWindow.toString();
}

/**
 * Utility Methods
 */

void drawBars() {
    for(int i = MIN_INDEX; i < SPECTRUM_SIZE; i++)
    {
        Note note_l = song.notes_l[i];
        Note note_r = song.notes_r[i];

        color col = note_l.getColor();
        stroke(col);
        fill(col);

        float l_height = note_l.scaledMag();
        float r_height = note_r.scaledMag();
        int lpos = (int) (leftPosition(note_l) * (float) width);
        int rpos = (int) (rightPosition(note_l) * (float) width);
        // System.out.println("Freq: " + note_l.freq + "\tlpos: " + lpos + "\trpos: " + rpos);
        rect(lpos, height/2, rpos-lpos, l_height);
        rect(lpos, height/2, rpos-lpos, -1*r_height);
    }
}

void drawWaveform() {
    int waveformRangeFactor = 8;
    float minFreq = song.fft_l.indexToFreq((int) SPECTRUM_SIZE / waveformRangeFactor);
    float maxFreq = song.fft_l.indexToFreq((int) SPECTRUM_SIZE);
    for(int i = SPECTRUM_SIZE/waveformRangeFactor; i < SPECTRUM_SIZE; i++)
    {
        Note note_l = song.notes_l[i];
        Note note_r = song.notes_r[i];

        color lcol = note_l.getColor();
        color rcol = note_r.getColor();

        float l_height = note_l.scaledMag();
        float r_height = note_r.scaledMag();
        int lpos = width - (int) ((freqToPosition(note_l.minFreq(), minFreq, maxFreq)) * (float) width);
        int rpos = width - (int) ((freqToPosition(note_l.maxFreq(), minFreq, maxFreq)) * (float) width);

        // TODO: normalize waveform scale while preserving spectrum scale. Not easy!
        float l_center = height/4 + song.song.left.get(i)*height/8;
        float r_center = 3*height/4 + song.song.right.get(i)*height/8;
        stroke(lcol);
        fill(lcol);
        rect(lpos, l_center - l_height/2, rpos-lpos, l_height);
        stroke(rcol);
        fill(rcol);
        rect(rpos, r_center - r_height/2, rpos-lpos, r_height);
        /*
        line(i, height/4 + song.song.left.get(i)*height/8,
             i+1, height/4 + song.song.left.get(i+1)*height/8);
        line(i, 3*height/4 + song.song.right.get(i)*height/8,
             i+1, 3*height/4 + song.song.right.get(i+1)*height/8);
        */
    }
}

void drawDebug() {
    text("WINDOW:" + windowName, 5, 20);
    text("GAIN: " + GAIN, 5, 40);

    if (DEBUG == true) {
        for (int i=0; i<HUE_MAP.length; i++) {
            color col = color(HUE_MAP[i],
                              NUM_COLORS*4,
                              NUM_COLORS);
            stroke(col);
            fill(col);
            int boxwidth = 2;
            rect(20 + i*boxwidth, 15*height/16, boxwidth, height/32);
        }
    }
}

/*
 * Wrapper for a minim AudioPlayer with async two-channel FFT
 */
class Song implements Runnable {

    public AudioPlayer song;

    public int num_samples;
    public FFT fft_l;
    public FFT fft_r;
    public Note[] notes_l;
    public Note[] notes_r;

    public Song(Minim minim, String filename, int num_samples) {
        /*
        if (PLAY_MODE == Mode.LINEIN)
            this.song = minim.getLineIn();
         */
        if (PLAY_MODE == Mode.MUSIC)
            this.song = minim.loadFile(filename, num_samples);

        this.num_samples = num_samples;

        // init fft's
        this.fft_l = new FFT(this.song.bufferSize(), this.song.sampleRate());
        this.fft_r = new FFT(this.song.bufferSize(), this.song.sampleRate());
        this.fft_l.forward(this.song.left);
        this.fft_r.forward(this.song.right);

        // init notes
        notes_l = new Note[num_samples];
        notes_r = new Note[num_samples];
        this.updateNotes();
    }

    @Override
    public void run() {
        if (PLAY_MODE == Mode.MUSIC) {
            this.song.play();
        }

        while (true) {
            this.fft_l.forward(this.song.left);
            this.fft_r.forward(this.song.right);
            this.updateNotes();
        }
    }

    private void updateNotes() {
        for (int i=0; i < SPECTRUM_SIZE; i++) {
            float freq = this.fft_l.indexToFreq(i);
            notes_l[i] = new Note(freq, this.fft_l.getBand(i));
            notes_r[i] = new Note(freq, this.fft_r.getBand(i));
        }
    }
}

/**
 * Representation of a note
 */
class Note {
    // Frequency of note in Hz
    private float freq;
    // Raw magnitude of note from fft
    private float mag;

    public Note(float freq, float mag) {
        this.freq = freq;
        this.mag = mag;
    }

    public float scaledMag() {
        return (float) (this.mag * GAIN * (float) Math.log10(freq));
    }

    public color getColor() {
        return freqToColor((int) this.freq, this.mag);
    }

    public float minFreq() {
        if ((int) this.freq == MIN_FREQ) {
            return this.freq;
        }
        return this.freq - BANDWIDTH / 2.0;
    }

    public float maxFreq() {
        if ((int) this.freq == MAX_FREQ) {
            return this.freq;
        }
        return this.freq + BANDWIDTH / 2.0;
    }
}

/*
 * Set HUE_MAP values for all pitches
 */
void fillColorMap(Song song) {
    HUE_MAP = new int[NUM_COLORS];
    for (int i=0; i < NUM_COLORS; i++) {
        if (SPECTYPE == SpecType.RAINBOW) {
            HUE_MAP[i] = i;
        }
    }
}

float log2(float x) {
    return (float) (Math.log((float) x) / Math.log(2.0f));
}

/**
 * Relative horizontal position scaled to pitch space
 * Returns [0,1]
 */
float freqToPosition(float freq) {
    return (
                (log2(freq) - log2(MIN_FREQ)) /
                (log2(MAX_FREQ) - log2(MIN_FREQ))
            );
}

float freqToPosition(float freq, float minFreq, float maxFreq) {
    return (
                (log2(freq) - log2(minFreq)) /
                (log2(maxFreq) - log2(minFreq))
            );
}

/**
 * Given a frequency in Hz, normalize to pitch space
 *
 * The resulting value will be in [0, 1], with A440 being at 0
 */
float normalizeFrequency(float freq) {
    float normFreq = ((log2(freq) % 1f) - (log2(440f) % 1f) + 1f) % 1f;
    assert normFreq >= 0 : "less than 0: " + freq + "\t" + normFreq;
    assert normFreq <= 1 : "more than 1: " + freq + "\t" + normFreq;
    return normFreq;
}

/**
 * Return the leftmost pixel for this note's box
 */
float leftPosition(Note note) {
    return freqToPosition(note.minFreq());
}

/**
 * Return the rightmost pixel for this note's box
 */
float rightPosition(Note note) {
    return freqToPosition(note.maxFreq());
}

/*
 * Given frequency, get the corresponding color
 */
color freqToColor(int freq) {
    int hueIndex = (int) (normalizeFrequency(freq) * NUM_COLORS);
    return color(HUE_MAP[hueIndex],
                 NUM_COLORS*4,
                 NUM_COLORS);
}

color freqToColor(int freq, float mag) {
    int hueIndex = (int) (normalizeFrequency(freq) * NUM_COLORS);
    return color(HUE_MAP[hueIndex],
                 (int) (Math.log10(mag)*NUM_COLORS*Math.log10(freq)/4.),
                 NUM_COLORS);
}

void stop() {
    song.song.close();
    minim.stop();

    super.stop();
}
