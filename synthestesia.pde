/**
  * This sketch demonstrates how to use an FFT to analyze
  * the audio being generated by an AudioPlayer.
  * <p>
  * FFT stands for Fast Fourier Transform, which is a
  * method of analyzing audio that allows you to visualize
  * the frequency content of a signal. You've seen
  * visualizations like this before in music players
  * and car stereos.
  * <p>
  * For more information about Minim and additional features,
  * visit http://code.compartmental.net/minim/
  */

import ddf.minim.analysis.*;
import ddf.minim.*;

Minim       minim;
Song song;
String windowName;


// filename of song, relative to project
String SONG_NAME = "example-music/bensound-cute.mp3";
// String SONG_NAME = "example-music/bensound-buddy.mp3";
// String SONG_NAME = "example-music/bensound-happyrock.mp3";
// sample rate of the FFT
int FFT_SAMPLES = 1024 * 2;
// Horizontal scaling factor for note bars
int BAR_WIDTH;
// Vertical scaling factor, controlled with -/= keys
int GAIN = 10;
// Number of subdivisions in the color map
int NUM_COLORS = 256;
// map integer frequencies to hues
int[] HUE_MAP;
// Min/max possible frequency in the spectrum
int MIN_FREQ;
int MAX_FREQ;

/**
 * Processing Framework functions
 */
void setup()
{
    size(2048, 800, P3D);
    colorMode(HSB, NUM_COLORS);

    minim = new Minim(this);
    song = new Song(minim, SONG_NAME, FFT_SAMPLES);
    Thread songthread = new Thread(song);

    BAR_WIDTH = 2*width / song.song.mix.size();

    System.out.println("Loaded song name: " + SONG_NAME);
    System.out.println("Song samples: " + FFT_SAMPLES);
    System.out.println("Song specsize: " + song.fft_l.specSize());
    System.out.println("Bar width: " + BAR_WIDTH);

    MIN_FREQ = (int) song.fft_l.indexToFreq(0);
    MAX_FREQ = (int) song.fft_l.indexToFreq(song.fft_l.specSize());
    System.out.println("Min frequency: " + MIN_FREQ);
    System.out.println("Max frequency: " + MAX_FREQ);

    fillColorMap(song);
    songthread.start();

    textFont(createFont("Arial", 16));

    windowName = "Rectangular Window";
}

void draw()
{
    background(0);
    stroke(255);
    fill(255);

    drawBars();
    drawWaveform();
    drawDebug();
}

void keyReleased() {
    WindowFunction newWindow = FFT.NONE;
    
    switch (key) {
        case '1': newWindow = FFT.BARTLETT; break;
        case '2': newWindow = FFT.BARTLETTHANN; break;
        case '3': newWindow = FFT.BLACKMAN; break;
        case '4': newWindow = FFT.COSINE; break;
        case '5': newWindow = FFT.GAUSS; break;
        case '6': newWindow = FFT.HAMMING; break;
        case '7': newWindow = FFT.HANN; break;
        case '8': newWindow = FFT.LANCZOS; break;
        case '9': newWindow = FFT.TRIANGULAR; break;
        case '=': GAIN += 1; break;
        case '-': GAIN -= 1; break;
    }

    song.fft_l.window(newWindow);
    song.fft_r.window(newWindow);
    windowName = newWindow.toString();
}

/**
 * Utility Methods
 */

/*
 * Set COLOR_MAP values for every possible integer frequency
 */
void fillColorMap(Song song) {
    HUE_MAP = new int[MAX_FREQ-MIN_FREQ];
    for (int i=0; i < MAX_FREQ-MIN_FREQ; i++) {
        HUE_MAP[i] = freqToHue(i);
    }
}

/*
 * Convert an integer frequency to corresponding hue
 *
 * Octaves are mapped to hues, so an A2 will have the same hue as an A3 or A4
 *
 * For now, we'll just use rainbows. In the future we may get fancy with
 * the circle of fifths.
 */
int freqToHue(int freq) {
    // Take log_2 of the frequency to map into pitch space
    // Mod by one because in pitch space octaves are size 1
    float pitch = (float) (Math.log(freq) / Math.log(2) % 1.);
    int hew = (int) (pitch * NUM_COLORS);
    return hew;
}

/* 
 * Given frequency, get the corresponding color
 */
color freqToColor(int freq) {
    return color(HUE_MAP[freq], NUM_COLORS*4, NUM_COLORS);
}

void drawBars() {
    for(int i = 0; i < song.fft_l.specSize(); i++)
    {
        color col = freqToColor((int) song.fft_l.indexToFreq(i));
        stroke(col);
        fill(col);
        // draw the line for frequency band i, scaling it up a bit so we can see it
        float l_height = getBandHeight(song.fft_l, i);
        float r_height = getBandHeight(song.fft_r, i);
        rect(i*BAR_WIDTH, height/2, BAR_WIDTH, l_height);
        rect(i*BAR_WIDTH, height/2, BAR_WIDTH, -1*r_height);
    }
}

/*
 * Given sepectrum index i and an FFT, get scaled band height
 */
float getBandHeight(FFT fft, int index) {
    return (float) (fft.getBand(index) * GAIN * (float) Math.log10(index));
}
    

void drawWaveform() {
    stroke(255);
    fill(255);
    for(int i = 0; i < song.song.left.size() - 1; i++)
    {
        line(i, height/4 + song.song.left.get(i)*50,
             i+1, height/4 + song.song.left.get(i+1)*50);
        line(i, 3*height/4 + song.song.right.get(i)*50,
             i+1, 3*height/4 + song.song.right.get(i+1)*50);
    }
}

void drawDebug() {
    text("WINDOW:" + windowName, 5, 20);
    text("GAIN: " + GAIN, 5, 40);
}

/*
 * Wrapper for a minim AudioPlayer with async two-channel FFT
 */
class Song implements Runnable {
    public AudioPlayer song;
    public int num_samples;
    public FFT fft_l;
    public FFT fft_r;

    public Song(Minim minim, String filename, int num_samples) {
        this.num_samples = num_samples;
        this.song = minim.loadFile(filename, num_samples);
        this.fft_l = new FFT(this.song.bufferSize(), this.song.sampleRate());
        this.fft_r = new FFT(this.song.bufferSize(), this.song.sampleRate());
    }

    @Override
    public void run() {
        this.song.play();

        while (true) {
            this.fft_l.forward(this.song.left);
            this.fft_r.forward(this.song.right);
        }
    }
}

void stop()
{
    // always close Minim audio classes when you finish with them
    song.song.close();
    minim.stop();

    super.stop();
}
